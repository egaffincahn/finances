overspent_updated <- 0
# keep remaining_updated the same
accounted_updated <- -filter(ledger.budgets, cat == "accounted")$amount
} else { # truly overspent
overspent_updated <- -remaining_updated
remaining_updated <- 0
accounted_updated <- -(filter(ledger.budgets, cat == "accounted")$amount + filter(ledger.budgets, cat == "remaining")$amount)
}
ledger.budgets <- data.frame(amount = c(accounted_updated, remaining_updated, overspent_updated),
cat = factor(c("accounted", "remaining", "overspent"), levels = c("overspent", "remaining", "accounted")),
UNIT = factor("money", levels = c("money", "days")))
past <- ifelse(mo == currentMonth() && yr == currentYear(), currentDay(), monthDays(componentsToDate(yr = yr, mo = mo)))
future <- monthDays(componentsToDate(yr = yr, mo = mo)) - past
ledger.budgets <- ledger.budgets %>% rbind(c(past, "accounted", "days")) %>% rbind(c(future, "remaining", "days")) %>%
filter(!(amount == 0 & UNIT == "money")) %>% group_by(UNIT) %>% do({
accounted.percent <- as.numeric(filter(., cat == "accounted")$amount) / sum(as.numeric(.$amount))
is.accounted <- .$cat == "accounted"
data.frame(amount = as.numeric(.$amount), cat = .$cat, UNIT = .$UNIT,
annotation.positions = (is.accounted * accounted.percent + (!is.accounted) * (accounted.percent + 1)) / 2)
})
g <- ggplot(ledger.budgets, aes(1, y = amount, fill = cat)) +
geom_bar(stat = "identity", position = "fill") + facet_grid(.~UNIT) + coord_polar(theta = "y") +
theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank()) +
labs(title = "Days and Budgets Remaining in Month", fill = "") +
scale_fill_manual(values = c("overspent" = "red", "remaining" = "green", "accounted" = "black")) +
geom_text(aes(1, annotation.positions, label = amount), color = "white")
return(g)
}
#' Gets a reduced ledger for easier plotting based on a given month and certain specifications
#' @export
.plotBudgetsDate <- function(ledger, yr, mo, budget.categories) {
account.categories <- viewAccountCategories()
budgeted <- unname(viewBudgets(suppress = TRUE)[budget.categories])
ledger.budgets <- data.frame(budget.category = factor(budget.categories, levels = budget.categories[order(abs(budgeted))]),
overearned = numeric(length(budget.categories)),
overspent = numeric(length(budget.categories)),
remaining = numeric(length(budget.categories)),
accounted = numeric(length(budget.categories)))
happened <- lapply(budget.categories, function(x) {
ledger.mini <- filter(ledger, year == yr, month == mo, budget.category == x)
ifelse(nrow(ledger.mini) == 0, 0, sum(ledger.mini[, account.categories]))
}) %>% unlist
for (i in seq(budget.categories)) {
if (budget.categories[i] %in% viewBudgetCategoriesSpending()) {
ledger.budgets[i, ]$overearned <- max(happened[i], 0)
ledger.budgets[i, ]$overspent <- min(happened[i] - budgeted[i], 0)
ledger.budgets[i, ]$remaining <- min(budgeted[i] - happened[i], 0)
ledger.budgets[i, ]$accounted <- min(max(budgeted[i], happened[i]), 0)
} else if (budget.categories[i] %in% viewBudgetCategoriesReal()) { # adds wages
ledger.budgets[i, ]$overearned <- max(happened[i] - budgeted[i], 0)
ledger.budgets[i, ]$overspent <- min(happened[i], 0)
ledger.budgets[i, ]$remaining <- min(max(budgeted[i] - happened[i], 0), budgeted[i])
ledger.budgets[i, ]$accounted <- min(max(happened[i], 0), budgeted[i])
} else if (budget.categories[i] %in% viewBudgetCategoriesAll()) { # adds the weird ones
ledger.budgets[i, ]$overearned <- max(happened[i], 0)
ledger.budgets[i, ]$overspent <- min(happened[i], 0)
}
}
ledger.budgets <- gather(ledger.budgets, cat, amount, -budget.category)
ledger.budgets$cat <- factor(ledger.budgets$cat, levels = c("overearned", "remaining", "overspent", "accounted"))
return(ledger.budgets)
}
#' descriptions...
#' @export
.binFun <- function(ledger.tbl, fun) {
ledger.tbl <- do(ledger.tbl, {
data.frame(amount = fun(.$amount))
})
ledger.tbl$date <- as.Date(ledger.tbl$date)
ledger <- as.data.frame(ledger.tbl)
return(ledger)
}
#' descriptions...
#' @export
.binByDate <- function(ledger, by = "month") {
ledger.tbl <- ledger %>%
ungroup() %>%
mutate(date = cut.Date(ledger$date, breaks = seq.Date(ledger$date[1], Sys.Date()+31, by = by))) %>%
group_by(date)
return(ledger.tbl)
}
#' @title Get date info
#'
#' @importFrom Hmisc monthDays
#'
#' @description The \code{current} series gets today's year, month, or day,
#'   returning just an integer. The \code{last} series (including
#'   \code{yesterday}) returns a full \code{Date} class for a recent date for
#'   easily providing values to the \code{from} input argument in other
#'   functions. For custom dates, use \code{componentsToDate}. To return today's
#'   date in the proper format, call \code{componentsToDate()}.
#'
#' @return Each of the \code{current*} functions return an integer. \code{last*}
#'   and \code{componentsToDate} return a \code{Date} class.
#'
#' @name ViewDate
#'
#' @export
#' @rdname ViewDate
currentDay <- function() {
as.numeric(format(Sys.Date(), "%d"))
}
#' @export
#' @rdname ViewDate
currentMonth <- function() {
as.numeric(format(Sys.Date(), "%m"))
}
#' @export
#' @rdname ViewDate
currentYear <- function() {
as.numeric(format(Sys.Date(), "%Y"))
}
#' @export
#' @rdname ViewDate
yesterday <- function() {
.wrapDate(currentYear(), currentMonth(), currentDay() - 1)
}
#' @export
#' @rdname ViewDate
lastWeek <- function() {
.wrapDate(currentYear(), currentMonth(), currentDay() - 7)
}
#' @export
#' @rdname ViewDate
lastMonth <- function() {
.wrapDate(currentYear(), currentMonth() - 1, currentDay())
}
#' @export
#' @rdname ViewDate
lastYear <- function() {
.wrapDate(currentYear() - 1, currentMonth(), currentDay())
}
#' @export
#' @rdname ViewDate
componentsToDate <- function(yr = currentYear(), mo = currentMonth(), dy = currentDay()) {
as.Date(paste(yr, mo, dy, sep = "-"), format = "%Y-%m-%d")
}
#' @export
.wrapDate <- function(year, month, day) {
while (month < 1) {
month <- month + 12
year <- year - 1
}
while (month > 12) {
month <- month - 12
year <- year + 1
}
while (day < 1) {
month <- month - 1
while (month < 1) {
month <- month + 12
year <- year - 1
}
day <- day + monthDays(componentsToDate(mo = month))
}
while (day > monthDays(componentsToDate(mo = month))) {
day <- day - monthDays(componentsToDate(mo = month))
month <- month + 1
while (month > 12) {
month <- month - 12
year <- year + 1
}
}
componentsToDate(year, month, day)
}
#' @title Add, edit or view transactions
#'
#' @name AddTransaction
#'
#' @import tidyverse
#'
#' @description Add a transaction to the ledger manually via inputs to the
#'   console with \code{addTransactionManual}, or automatically by reading from
#'   a file with \code{addTransactionAuto}. You can see what the transactions
#'   are that would be automatically entered with
#'   \code{viewTransactionsAutoLoad}.\cr \code{editTransaction} will display the
#'   transactions for the given year, month, day. It defaults to show the
#'   current month's. If \code{yr}, \code{mo}, \code{dy} is \code{NULL}, it will
#'   show transactions from all years, months, days, respectively, within the
#'   others. It also takes other arguments to narrow the options to show. These
#'   options are the same as for \code{viewLedger}, because
#'   \code{editTransaction} will call the former to limit the options shown. \cr
#'   \code{viewLedgerMonth} is a convenient wrapper to show the transactions for
#'   just the current month. Instead, the functions with date subdivisions are
#'   more appropriate. This is the appropriate way to view a reasonable number
#'   of transactions at one time. It takes the \code{year}, \code{month}, and
#'   \code{day} to prune down the ledger. If any date specification is
#'   \code{NULL}, it allows all values for that specific date column.
#'   \code{year} and \code{month} default to \code{currentYear()} and
#'   \code{currentMonth()}, while \code{day} defaults to all values via
#'   \code{NULL}. The ledger can further be restricted by including an early or
#'   late bound with \code{from} and \code{to}. These require a \code{Date}
#'   type. You can use \code{componentsToDate} to build one using a year, month,
#'   and day. Both methods can be done alone or in tandem.\cr For a transaction
#'   to be shown, it has to fit ALL of the input argument criteria. However,
#'   each of the input arguments can be a single value or can be a vector. If
#'   one is a vector, a transaction that fits any of the values in the vector
#'   will be shown.
#'
#'
#' @inheritParams viewLedger
#' @param descriptions Values in the descriptions column to search for. Uses
#'   regular expressions.
#' @param budget.categories Values from the factor column of budget category to
#'   search for. Must be exact.
#' @param amount.ops,account.amounts Operators to search transactions. For
#'   example, to find transactions where more than one thousand dollars were
#'   spent, use \code{amount.ops = `<`, account.amounts = -1000}.
#' @param account.categories Restricts the transactions shown to ones where the
#'   account(s) in this argument are not 0.
#' @param query Asks the user for descriptions, transaction amounts, etc.
#'   manually. Queried values will overwrite the input arguments. Default
#'   behavior is to query if all the input options are \code{NULL}.
#'
#'
#' @rdname AddTransaction
#' @export
addTransactionManual <- function(ledger = viewLedger(file = file), file = viewLedgerFile(), description = NULL,
budget = NULL, date = NULL, account = NULL, amount = NULL) {
new.rows <- ledger[1,]
new.rows$ID <- NA
new.rows$description <- ifelse(is.null(description), .addTransactionDescription(), description)
new.rows$date <- if (is.null(date)) {
as.Date(paste(.addTransactionYear(), .addTransactionMonth(), .addTransactionDay(), sep = "-"))
} else {
date
}
new.rows$budget <- ifelse(is.null(budget), .addTransactionBudgetCategory(), budget)
account.amounts <- if (is.null(account) || is.null(amount)) {
.addTransactionAccountCategory(ledger)
} else {
data.frame(account = account, amount = amount)
}
for (i in 1:nrow(account.amounts)) {
new.rows$account[i] <- account.amounts$account[i]
new.rows$amount[i] <- account.amounts$amount[i]
if (i != nrow(account.amounts)) {
new.rows <- rbind(new.rows, new.rows[1,])
}
}
ledger <- .shiftIDs(ledger, new.rows)
saveLedger(ledger, file)
}
#' @rdname AddTransaction
#' @export
addTransactionAuto <- function(ledger = viewLedger(file = file), file = viewLedgerFile()) {
load(.dataLocation())
transactions <- viewTransactionsAutoLoad()
new.rows <- ledger[1,]
new.rows$ID <- NA
for (i in 1:nrow(transactions)) {
new.rows$date[i] <- as.Date(transactions$V1[i], format = "%Y-%m-%d")
new.rows$description[i] <- transactions$V2[i]
new.rows$budget[i] <- transactions$V3[i]
new.rows$account[i] <- transactions$V4[i]
new.rows$amount[i] <- transactions$V5[i]
if (i != nrow(transactions)) {
new.rows <- rbind(new.rows, new.rows[1,])
}
}
id <- 0
ids <- numeric(nrow(new.rows))
new.rows.mini <- select(new.rows, description, budget, date)
for (i in 1:nrow(new.rows)) {
if (i == 1 || !all(sapply(1:ncol(new.rows.mini), function(x) new.rows.mini[i,x] == new.rows.mini[i-1,x]))) id <- id + 1
ids[i] <- id
}
for (i in seq(unique(ids))) {
ledger <- .shiftIDs(ledger, filter(new.rows, ids == i))
ledger <- arrange(ledger, ID)
}
write(data.frame(), file = auto.add.transaction, ncolumns = 1)
saveLedger(ledger, file)
}
#' @rdname AddTransaction
#' @export
viewTransactionsAutoLoad <- function(suppress = TRUE) {
load(.dataLocation())
transactions <- read.csv(auto.add.transaction, header = FALSE, stringsAsFactors = FALSE) # try catch?
return(transactions)
}
#' @rdname AddTransaction
#' @export
editTransaction <- function(ledger = viewLedger(file = file), file = viewLedgerFile(), ...) {
ledger.mini <- viewLedger(ledger = ledger, ..., suppress = FALSE)
id <- NA
while (is.na(id)) id <- as.numeric(readline("Enter transaction ID to edit: "))
ledger.mini <- filter(ledger.mini, ID == id)
print(ledger.mini)
change.fields.allowed <- c("date", "description", "budget", "account")
print(change.fields.allowed)
change.field <- "placeholder that's not empty"
while (change.field != "") {
change.field <- readline("Which field to change: Or enter delete. ")
if (change.field == "delete") {
ledger <- filter(ledger, ID != id)
ledger <- .shiftIDs(ledger, new.rows = NULL)
break()
} else if (change.field == "date") {
new.rows <- filter(ledger, ID == id)
new.rows$ID <- NA
new.rows$date <- as.Date(paste(.addTransactionYear(), .addTransactionMonth(), .addTransactionDay(), sep = "-"))
ledger <- filter(ledger, ID != id)
ledger <- .shiftIDs(ledger, NULL)
ledger <- .shiftIDs(ledger, new.rows)
} else if (change.field == "description") {
ledger$description[ledger$ID == id] <- readline("Enter description: ")
} else if (change.field == "budget") {
ledger$budget[ledger$ID == id] <- .addTransactionBudgetCategory()
} else if (change.field == "account") {
print("Warning: this resets all the account charges from this transaction ID.")
account.amounts <- .addTransactionAccountCategory(ledger = ledger.mini)
tempRow <- ledger[which(ledger$ID == id)[1], ]
ledger <- filter(ledger, ID != id)
for (i in 1:nrow(account.amounts)) {
tempRow$account <- account.amounts$account[i]
tempRow$amount <- account.amounts$amount[i]
ledger <- rbind(ledger, tempRow)
}
ledger <- arrange(ledger, ID)
} else if (change.field != "") {
print(paste("Unknown field to change:", change.field))
}
}
saveLedger(ledger, file)
}
#' @export
.shiftIDs <- function(ledger, new.rows) {
if (is.null(new.rows)) { # shifting from deleted transaction
startRow <- (which(diff(ledger$ID) == 2)+1)
if (length(startRow) >= 0) {
shiftRows <- startRow:nrow(ledger)
ledger$ID[shiftRows] <- ledger$ID[shiftRows] - 1
}
return(ledger)
}
# assumes only one new transaction (one transaction ID, all same date, etc)
startRow <- which(ledger$date <= new.rows$date[1]) %>% {.[length(.)]} + 1
if (startRow > nrow(ledger)) {
ledger <- rbind(ledger, new.rows)
ledger$ID[startRow:(startRow+nrow(new.rows)-1)] <- ledger$ID[startRow-1] + 1
} else {
ledger <- rbind(ledger[1:(startRow-1),], new.rows, ledger[startRow:nrow(ledger),])
ledger$ID[startRow:(startRow+nrow(new.rows)-1)] <- ledger$ID[startRow+nrow(new.rows)] # ID of new transaction
ledger$ID[(startRow+nrow(new.rows)):nrow(ledger)] <- ledger$ID[(startRow+nrow(new.rows)):nrow(ledger)] + 1 # update IDs transactions already included
}
return(ledger)
}
#' @export
.addTransactionYear <- function() {
yr <- readline("Enter year or leave blank for current: ")
yr <- ifelse(yr == "", currentYear(), yr)
return(yr)
}
#' @export
.addTransactionMonth <- function() {
mo <- readline("Enter month or leave blank for current: ")
mo <- ifelse(mo == "", currentMonth(), mo)
return(mo)
}
#' @export
.addTransactionDay <- function() {
dy <- readline("Enter day or leave blank for current: ")
dy <- ifelse(dy == "", currentDay(), dy)
return(dy)
}
#' @export
.addTransactionDescription <- function() {
description <- ""
while (description == "") description <- readline("Enter description: ")
return(description)
}
#' @export
.addTransactionBudgetCategory <- function() {
existing.categories <- viewBudgetCategoriesAll(suppress = FALSE)
budget <- readline("Enter budget category from above or its index: ")
if (suppressWarnings(!is.na(as.numeric(budget)))) budget <- viewBudgetCategoriesAll()[as.numeric(budget)]
budget.temp <- "placeholder"
while (!(budget %in% existing.categories) && budget.temp != "") {
budget.temp <- readline(paste(budget, "is not a current budget category. Enter a new one or leave blank to add. "))
if (budget.temp != "") budget <- budget.temp
}
return(budget)
}
#' @export
.addTransactionAccountCategory <- function(ledger = viewLedger(file = file), file = viewLedgerFile()) {
account.amounts <- data.frame(account = numeric(), amount = numeric())
existing.categories <- viewAccountCategories(ledger = ledger, suppress = FALSE)
while (TRUE) {
account <- readline("Enter account category from above or its index: ")
if (account == "") break()
if (suppressWarnings(!is.na(as.numeric(account)))) account <- viewAccountCategories()[as.numeric(account)]
account.temp <- "placeholder"
while (!(account %in% existing.categories) && account.temp != "") {
account.temp <- readline(paste(account, "is not a current account. Enter a new one or leave blank to add. "))
if (account.temp != "") account <- account.temp
}
amount <- as.numeric(readline(paste("Enter amount for ", account, ": ", sep = "")))
account.amounts <- rbind(account.amounts, data.frame(account = account, amount = amount))
}
return(account.amounts)
}
#' @rdname AddTransaction
#' @export
viewLedgerMonth <- function(ledger = viewLedger(file = file), file = viewLedgerFile()) {
viewLedger(ledger = ledger, from = componentsToDate(dy = 1))
}
plotAccountsChange()
library(tidyverse)
plotAccountsChange()
plotAccountsCumulative()
plotAssetsChange()
plotAssetsCumulative()
ggplotly()
library(plotly)
ggplotly()
plotAccountsChange())
plotAccountsChange()
plotAccountsCumulative()
ggplotly()
addTransactionManual()
viewLedger(from = lastWeek())
library(Hmisc)
viewLedger(from = lastWeek())
viewLedger %>% group_by(account) %>% do({data.frame(n = nrow(.))})
viewLedger() %>% group_by(account) %>% do({data.frame(n = nrow(.))})
m <- viewLedger() %>% group_by(account) %>% do({data.frame(n = nrow(.))})
m[order(m$n),]
ggplot(m, aes(account, n)) + geom_point()
m <- as.data.frame(m)
m
m <- m[order(m$n),]
ggplot(m, aes(account, n)) + geom_point()
m
m$account <- factor(m$account)
ggplot(m, aes(account, n)) + geom_point()
m
levels(m$account)
m$account <- factor(m[,1])
levels(m$account)
m
ggplot(m, aes(account, n)) + geom_point()
m$account <- factor(m$account, levels = m$account)
ggplot(m, aes(account, n)) + geom_point()
ggplot(m, aes(account, n)) + geom_point() + scale_y_log10() + theme_minimal()
ggplot(m, aes(account, n)) + geom_point() + theme_minimal()
source('~/GitHub/finances_new/R/ViewLedger.R', echo=TRUE)
source('~/GitHub/finances_new/R/ViewInfo.R', echo=TRUE)
source('~/GitHub/finances_new/R/PlotFinances.R', echo=TRUE)
source('~/GitHub/finances_new/R/ViewDate.R', echo=TRUE)
source('~/GitHub/finances_new/R/AddTransaction.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
addTransactionManual()
source('~/GitHub/finances_new/R/ViewLedger.R', echo=TRUE)
source('~/GitHub/finances_new/R/ViewInfo.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/finances_new/R/PlotFinances.R', echo=TRUE)
source('~/GitHub/finances_new/R/ViewDate.R', echo=TRUE)
source('~/GitHub/finances_new/R/AddTransaction.R', echo=TRUE)
addTransactionManual()
addTransactionManual()
credit.CapOne
addTransactionManual()
qn()
source('~/GitHub/finances_new/R/ViewLedger.R', echo=TRUE)
source('~/GitHub/finances_new/R/ViewInfo.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/finances_new/R/PlotFinances.R', echo=TRUE)
source('~/GitHub/finances_new/R/ViewDate.R', echo=TRUE)
source('~/GitHub/finances_new/R/AddTransaction.R', echo=TRUE)
addTransactionManual()
devtools::install_github(repo = "egaffincahn/finances")
library("finances", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
remove.packages("finances")
devtools::install_github(repo = "egaffincahn/finances")
?devtools::install_github(repo = "egaffincahn/finances")
?devtools::install_github()
library(devtools)
?install_github
?install_github
?install_github
??devtools
?build
setwd("~/GitHub/finances/")
build(pkg = "finances", path = "~/GitHub/finances/")
build(path = "~/GitHub/finances/")
build(path = "~/GitHub/finances/")
build(path = "~/GitHub/finances/")
??namespace
??roxygen2
roxygen2::roxygenize()
build(path = "~/GitHub/finances/")
?build(path = "~/GitHub/finances/")
?build
devtools::install_github(repo = "egaffincahn/finances")
lf()
View(.binFun)
plotAssetsCumulative()
build(path = "~/GitHub/finances/")
?build(path = "~/GitHub/finances/")
devtools::build(path = "~/GitHub/finances/")
devtools::install_github(repo = "egaffincahn/finances")
?.binBy
?.binByDate()
?plotAssetsChange
devtools::build(path = "~/GitHub/finances/")
devtools::install_github(repo = "egaffincahn/finances")
?plotAssetsChange
lf()
?plotAssetsChange
plotAssetsChange
plotAssetsChange()
